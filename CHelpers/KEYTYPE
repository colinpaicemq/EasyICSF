#ifndef KEYTYPE_INCLUDE
#define KEYTYPE_INCLUDE
#define isRSA(a)      memcmp(&a[18] ,"RSA",3)     ==0
#define isECC(a)      memcmp(&a[18] ,"ECC",3)     ==0
#define isECCPRIV(a)  memcmp(&a[18] ,"ECCPRIV",7) ==0
#define isECCPUB(a)   memcmp(&a[18] ,"ECCPUB" ,6) ==0
#define isRSAPRIV(a)  memcmp(&a[18] ,"RSAPRIV",7) ==0
#define isRSAPUB(a)   memcmp(&a[18] ,"RSAPUB",6)  ==0
#define isAES(a)      memcmp(&a[9]  ,"SYM",3)     ==0
#define isAESFIXED(a) memcmp(&a[ 9] ,"AESFIX",6)  ==0
#define isEXPORTER(a) memcmp(&a[18] ,"EXP",3)     ==0
#define isIMPORTER(a) memcmp(&a[18] ,"IMP",3)     ==0
#define pECCType(a)          &a[27]
void doPub(char * pOutput,char * pFormat, char * pIn)
{
   char * pEnd;
   char * pCurr;
   short length;
   memcpy(&length,&pIn[2],2); // get the overall length
   int l;
   l = length;
   pEnd = pIn + length;
   pCurr = pIn + 8;
   for ( pCurr = pIn + 8; pCurr < pEnd;)
   {
     if (pCurr[0] == 0x04 ) break;
     memcpy(&length,&pCurr[2],2); // get the overall length
     pCurr += length;
   }
   if (pCurr[0] == 0x04 )
   {
     memcpy(&length,&pCurr[8],2); // get the overall length
     l = length;
   }
   else l =0;
   char temp[20];  // should be plenty long enough
   sprintf(&temp[0],pFormat,l);
   strcat(pOutput,temp);
}
void doECCType(char * pOutput,char * pFormat, char * pIn)
{
   char * pEnd;
   char * pCurr;
   short length;
   memcpy(&length,&pIn[2],2); // get the overall length
   int l;
   short ECCType;
   l = length;
   char * p    ;
   pEnd = pIn + length;
   pCurr = pIn + 8;
   for ( pCurr = pIn + 8; pCurr < pEnd;)
   {
     if (pCurr[0] == 0x20 ) break;
     memcpy(&length,&pCurr[2],2); // get the overall length
     pCurr += length;
   }
   if (pCurr[0] == 0x020)  // PUBLIC key
   {
     memcpy(&ECCType,&pCurr[12],2); // length and type as 2 bytes
     if (pCurr[9] ==  0x00) // PRIME NIST
     switch(ECCType)
     {
       case 0x00c0: p = "NI192   ";break;
       case 0x00E0: p = "NI224   ";break;
       case 0x0100: p = "NI256   ";break;
       case 0x0180: p = "NI384   ";break;
     }
     else
     if (pCurr[9] ==  0x01) // Brain pool
     switch(ECCType)
     {
       case 0x00A0: p = "BP160   ";break;
       case 0x00C0: p = "BP192   ";break;
       case 0x00E0: p = "BP224   ";break;
       case 0x0100: p = "BP256   ";break;
       case 0x0140: p = "BP320   ";break;
       case 0x0180: p = "BP384   ";break;
       case 0x0200: p = "BP512   ";break;
     }
     else
     if (pCurr[9] ==  0x02) // Edwards
     switch(ECCType)
     {
       case 0x00FF: p = "ED25519 ";break;
       case 0x01c0: p = "ED448   ";break;
     }
     else
     if (pCurr[9] ==  0x03) // Koblenz
     switch(ECCType)
     {
       case 0x0100: p = "KO256   ";break;
     }
     else p = "UNKNOWN ";
   }
   else p = "UNKNOWN ";
   char temp[20];  // should be plenty long enough
   sprintf(&temp[0],pFormat,p);
   strcat(pOutput,temp);
}
int keyType(char * pIn  , int lIn,
    char *  pData, int * lData)
{
  int length;
  char  output[60];
  output[0]=0;// say it is a null string
  memset(&output[0],0  ,sizeof(output));  // preset to nulls
  //output[sizeof(output)-1]=0; // null terminator
  //printHex(stdout,pIn,lIn);
  // printf("Keytype:\n");
  //printHex(stdout,pIn,16 );
  //
  if ( pIn[0] == 0x00                   )
  {
    strcpy(output,"NULL        ");
  }
  else
  //
  // Fixed
  //
  if ( pIn[3] == 0x00 ) // length field  is 0
  {
    if ( pIn[0] == 0x01 && pIn[4]== 0x04)
      strcpy(output,"INTERNAL AESFIXED ");
    else
    if (  pIn[0] == 0x01 &&(pIn[4]== 0x00 || pIn[4] == 0x01) )
      strcpy(output,"INTERNAL DESFIXED ");
    else
    if (  pIn[0] == 0x01 &&(pIn[4]== 0x00 || pIn[4] == 0x01))
      strcpy(output,"EXTERNAL DESFIXED ");
    else
    // external
    if (  pIn[0] == 0x02 &&(pIn[4]== 0x00 || pIn[4] == 0x01))
      strcpy(output,"EXTERNAL DESFIXED ");
    else
    if ( pIn[0] == 0x02 && pIn[4]== 0x10                  )
      strcpy(output,"EXTERNAL RXXDESFI ");
    else
    {
      printf("Unknown fixed field\n");
      printHex(stdout,pIn,lIn);
    }
  }
  // end of fixed
  //
  // variable symmetric
  //
  else
  if ( pIn[0] == 0x01 || pIn[0]== 0x02                  )
  {
    if ( pIn[0] == 0x01                                   )
       strcpy(output,"INTERNAL SYMMETRI ");
     else
    if ( pIn[0] == 0x02                                   )
       strcpy(output,"EXTERNAL SYMMETRI ");
    switch( pIn[43])
    {
       case  1:strcat(output,"CIPHER   ");break;
       case  2:strcat(output,"MAC      ");break;
       case  3:strcat(output,"EXPORTER ");break;
       case  4:strcat(output,"IMPORTER ");break;
       case  5:strcat(output,"PINPROT  ");break;
       case  6:strcat(output,"PINCALC  ");break;
       case  7:strcat(output,"PINPRW   ");break;
       case  8:strcat(output,"DESUSECV ");break;
       case  9:strcat(output,"DKYGENKY ");break;
       case 10:strcat(output,"SECMSG   ");break;
       default:strcat(output,"UNKNOWN  ");break;
    }
    switch( pIn[41])
    {
       case  1:strcat(output,"CANDES   ");break;
       case  2:strcat(output,"CANAES   ");break;
       case  3:strcat(output,"CANHMAC  ");break;
       default:strcat(output,"UNKNOWN  ");break;
    }
  }
  // end of var sym
  // start of PKA
  //
  else
  if ( pIn[0] == 0x1E || pIn[0]== 0x1F  )
  {
    if ( pIn[0] == 0x1E     )
       strcpy(output,"EXTERNAL PKA      ");
    else
    if ( pIn[0] == 0x1F   )
       strcpy(output,"INTERNAL PKA      ");
    switch(pIn[8 ])
    {
//                              123456789123456789
       case 0x02: doPub(output,"RSAPRIV  %.4uME   ",pIn);break;
       case 0x04: doPub(output,"RSAPUB   %.4u     ",pIn);break;
       case 0x06: doPub(output,"RSAPRIV  %.4uMEOP ",pIn);break;
       case 0x08: doPub(output,"RSAPRIV  %.4uCROP ",pIn);break;
       case 0x09: doPub(output,"RSAPRIV  %.4uMEEX ",pIn);break;
//     case 0x10: doPub(output,"RSAPRIV  KeyName  ",pIn);break;
       case 0x30: doPub(output,"RSAPRIV  %.4uMEAO ",pIn);break;
       case 0x31: doPub(output,"RSAPRIV  %.4uCRAO ",pIn);break;
#ifdef no
       case 0x06:strcat(output,"RSAPRIV  M1024OPK ");break;
       case 0x30:strcat(output,"RSAPRIV  ME4096OPK  ");break;
       case 0x09:strcat(output,"RSAPRIV  ME4096     ");break;
       case 0x08:strcat(output,"RSAPRIV  CRTOPK     ");break;
       case 0x31:strcat(output,"RSAPRIV  CRT4096OPK ");break;
//     case 0x04:strcat(output,"RSAPUB              ");
       case 0x04:
           memcpy(&s,&pIn[8+8],2);
           // cant use the following as it only does one characer
           //        sprintf(&temp[0],"RSAPUB  %u    \0", pIn[8+8]);
           sprintf(&temp[0],"RSAPUB   %.4hu     \0",s);
           strcat(output,temp);
           break;
  #endif
       case 0x10:strcat(output,"RSAPRIV  QSA        ");break;
       case 0x20:
             doECCType(output,"ECCPRIV  %8.8s",pIn);
             break;
       case 0x21:
             doECCType(output,"ECCUB    %8.8s",pIn);
             break;
       case 0x23:strcat(output,"ECC???   KEYDERIV   ");break;
       case 0x50:strcat(output,"QSAPRIV             ");break;
       case 0x51:strcat(output,"QSAPUB              ");break;
       default:  strcat(output,"UNKNOWN             ");break;
    }
  }
  else
  {
    printf("keytype:Unrecognised data \n");
    printHex(stdout,pIn,16);
    strcpy(output,"???????? ");
  }
  length = sizeof(output);
  if ( * lData < length        )
  {
     printf("keytype: input length %i needs %i\n",*lData,length);
     *lData = length        ;  // give true length
     return 4;
  }
  * lData = length           ;
  memcpy(pData,&output,length  );// include null terminator
  return 0;
}
 #endif
