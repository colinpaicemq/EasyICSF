#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include </usr/include/csfbext.h>
void listData(char which[8], char state[8]);
void metaData(char type[8],char * label);
typedef char    char8[8];

int main(int argc, char * argv[]) {
  listData("CKDS    ","ACTIVE  ");
  listData("CKDS    ","INACTIVE");
  listData("CKDS    ","ARCHIVE ");
  listData("PKDS    ","ACTIVE  ");
  listData("PKDS    ","INACTIVE");
  listData("PKDS    ","ARCHIVE ");
}
void listData(char which[8], char state[8])
{
  int rc;
  int rs;
  #define RULECOUNT 3
  int     ruleCount= RULECOUNT;
  char8 rule[RULECOUNT];
  memcpy(rule[0],which,8);
  memcpy(rule[1],"DETAILED",8);
  memcpy(rule[2],state,8);
  int label_count;
  int output_list_length = 4096;
      output_list_length = 112 ;
  char output_list[output_list_length];
  char continuation[100];
  memset(&continuation,0,sizeof(continuation));
  int myrc;
  int zero = 0;
  while(1)
  {
  myrc =
  CSFKDSL (
         &rc  ,                   /* return code                   */
         &rs  ,                   /* reason code                   */
         &zero,                   /* exit data length              */
         0              ,         /* exit data[]                   */
         &ruleCount,              /* rule array count              */
         (unsigned char* )  &rule,/* rule array[]                  */
         &zero,                   /* label filter length           */
         0              ,         /* label filter[]                */
         &zero,                   /* search criteria length        */
         0              ,         /* search criteria[]             */
         &label_count   ,         /* label count                   */
         &output_list_length,     /* output list length            */
         output_list,             /* output list[]                 */
         &zero ,                  /* reserved1 length              */
         0     ,                  /* reserved1[]                   */
         &zero ,                  /* reserved2 length              */
         0              ,         /* reserved2[]                   */
         &continuation[0] );      /* continuation area[]           */
      char * p;
      p =  &output_list[0];
      int s = output_list_length/112 ;
      int i;
      for (i = 0; i< s;i++){
         printf("%8.8s %8.8s %.64s %.8s %.8s %.8s %.8s %.8s %.8s\n",
                 which,state,p,p+64,p+72,p+80,p+88,p+96,p+104);
         metaData(which, p);
         p+= 112 ;
      }
      if ( rc == 4 && rs == 3303) continue;
      break;
}
return     ;
}
//
// metaData
//
void metaData(char type[8],char * label)
{
  int rc;
  int rs;
  int zero = 0;
  int ruleCount = 1;
  char output[1000];
  memset(&output,0,sizeof(output));
  int lOutput = sizeof(output);
  typedef struct  {
    short len;
    short type;
    char  data[16];
  } sOutput;
  char8 rule;
  // copy the input data base type
  memcpy(rule,type,8);

  struct {
    struct {
      short a; short v;
      } each[10];
  } metaData;
  // build meta data list
 typedef  struct item   {
    short code;
    char * label ;
    } item;

  item items[] =  { {2,"Record create date"},
                     {3,"Record update date"},
                     {4,"Key validity start date"},
                     {5,"Key validity end date"},
                     {6,"Last reference date"},
                     {7,"Last reference date stck"},
                     {8,"Archive date"},
                     {11,"1Recall date"}
                  };
  int size  = sizeof(items)/sizeof(items[0]);
  int i;
  for (i=0;i< size ;i++)
  {
     metaData.each[i].a= 4;             // size
     metaData.each[i].v=items[i].code;
  }

  int lMetaData = 4 * size; //ccp
  sOutput * p      ;
  CSFKDMR (
           &rc,                     /* return code                   */
           &rs,                     /* reason code                   */
           &zero,                   /* exit data length              */
           0,                       /* exit data[]                   */
           &ruleCount,              /* rule array count              */
  (char *) &rule,                   /* rule array[]                  */
           label,                   /* record label[]                */
           &lMetaData,              /* metadata list length          */
  (char *) &metaData,               /* metadata list[]               */
           &lOutput,                /* output list length            */
  (char *) &output,                 /* output list[]                 */
           &zero,                   /* reserved1 length              */
           0              ,         /* reserved1[]                   */
           &zero,                   /* reserved2 length              */
           0              );        /* reserved2[]                   */
    printf("CSFKDMR rc %i rs %i \n",rc,rs );
    if (rc == 4 &&  rs == 3302)
      printf("Database %8.8s is not in kdsr format rs 3302\n",type);
    if ( rc != 0) return;

    char * q;
    char * w;
    q       =  (char *)  &output;
    for ( q       =  (char *)  &output;
          q       < (char *)  &output + lOutput;)
    {
      p       = (sOutput *) q     ;
      for ( int i = 0; i < size;i ++)
      {
        w = "Unknown";
        if (items[i].code ==  p -> type)
        {
           w = items[i].label;
           break;
        }
      }
      if ( p->data[0] != 0)
      printf("output %hd  %hd %s %s\n",
        p-> len,p-> type,&(p->data[0]),w              );
  //    p-> len,p-> type,&(p->data[0]),which[p->type] );
      q+= p-> len;
    }
}
