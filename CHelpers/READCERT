
int
  readCert (char * dd, char ** pData, int * lData)
{
  #define SIZE 12000
  char *  pB64;
  pB64 = (char * ) malloc(SIZE);
  if (pB64 == 0)
  {
    printf("problem malloc storage in readCert\n");
    return  8;
  }
  int lB64 = SIZE;
  FILE * fCert = fopen(dd       ,"rb,type=record");
  if (fCert == NULL)
  {
    perror("error opening dataset ");
    printf("error opening %ss/n",dd);
    return 8;
  }
  int l = 0;
  int num;
  char * pIndata =     pB64;
  char buffer[80];
  int i;
  for (i= 0;; i++ )
  {
     num = fread(&buffer[0], sizeof(char),sizeof(buffer), fCert);
     if (num == 0   ) break;
     if (num >= 64)
     {
       memcpy(pIndata,&buffer[0],64);
       pIndata+=64;
      *pIndata = 0; // null terminator so we can print it
      l += 64;
     }
     else
     {
       memcpy(pIndata,&buffer[0],num);
       pIndata+=num;
       l+= num;
      *pIndata = 0;
       break;
     }
     if (l +64 > SIZE        )
     {
       printf("read certificate buffer is too small\n");
       return 8;
     }
     *pIndata = 0;
  }
  if ( l == 0)
  {
     printf("The length of the certificate read was 0\n");
     return 8;
  }
     printf("The length of the certificate read was %i\n",l);
  int yy;
  memcpy(& yy,pB64,4);
  // now convert the data back to hex
  unsigned int lPublic =0;
  // strip trailing nulls or blanks
  for (i = l-1 ; i >  0 ;  i--) // allow for - addressing
  {
      if (* (pB64 +i)            == ' ' // blank
          ||*(pB64 +i)           == 0  ) // null
      {
      continue;
      }
      else break;
  }
  l = i + 1;
  char * pPublic = base64_decode(pB64,
                                 l, // length of data
                                 &lPublic);
 int zz;
 memcpy(&zz,pPublic       ,4);
  * pData = pPublic;
  * lData = lPublic ;
  free(pB64);
  return 0;
}
